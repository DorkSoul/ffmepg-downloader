<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Video Downloader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card p {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
            background: white;
            cursor: pointer;
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            margin-top: 10px;
        }

        .status-section {
            grid-column: 1 / -1;
        }

        .status-box {
            display: none;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .status-box.active {
            display: block;
        }

        .status-box.success {
            border-color: #28a745;
            background: #d4edda;
        }

        .status-box.error {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .status-box h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .vnc-container {
            grid-column: 1 / -1;
            display: none;
        }

        .vnc-container.active {
            display: block;
        }

        .vnc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .vnc-header h2 {
            margin: 0;
        }

        .vnc-frame {
            width: 100%;
            height: 600px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #000;
        }

        .download-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
        }

        .download-popup.active {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scale(1);
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .popup-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .download-popup h3 {
            color: #28a745;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .download-popup .thumbnail {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #e0e0e0;
        }

        .download-popup .info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .download-popup .info p {
            margin-bottom: 8px;
            color: #333;
        }

        .countdown {
            text-align: center;
            color: #666;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .popup-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .downloads-list {
            grid-column: 1 / -1;
        }

        .downloads-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .download-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }

        .download-item h4 {
            color: #333;
            margin-bottom: 8px;
            font-size: 0.9rem;
            word-break: break-all;
        }

        .download-item p {
            color: #666;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .filename-error {
            color: #dc3545;
            font-size: 0.85rem;
            margin-top: 5px;
            display: none;
        }

        .filename-error.visible {
            display: block;
        }

        .input-group input.input-error {
            border-color: #dc3545;
        }

        .icon {
            font-size: 1.3rem;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Stream Selection Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s;
        }

        .modal.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h2 {
            color: #667eea;
            font-size: 1.8rem;
        }

        .close-modal {
            font-size: 32px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            transition: color 0.3s;
            line-height: 1;
        }

        .close-modal:hover {
            color: #333;
        }

        .streams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .stream-card {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s;
            background: white;
        }

        .stream-card:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .stream-thumbnail {
            width: 100%;
            height: 180px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 48px;
        }

        .stream-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .stream-details {
            margin-bottom: 12px;
        }

        .stream-details h3 {
            color: #333;
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .stream-detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #666;
        }

        .stream-detail-label {
            font-weight: 600;
        }

        .stream-download-btn {
            width: 100%;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .stream-download-btn:hover {
            background: #5568d3;
        }

        .stream-download-btn:active {
            background: #4554bc;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üé¨ Universal Video Downloader</h1>
            <p>Download videos with browser-based authentication and stream detection</p>
        </header>

        <div class="main-content">
            <!-- Direct Download Mode -->
            <div class="card">
                <h2><span class="icon">‚ö°</span> Direct Download</h2>
                <p>Download directly from a known stream URL (.m3u8, .mpd, .mp4)</p>

                <div class="input-group">
                    <label for="direct-url">Stream URL</label>
                    <input type="text" id="direct-url" placeholder="https://example.com/stream.m3u8" required>
                </div>

                <div class="input-group">
                    <label for="direct-filename">Filename (optional)</label>
                    <input type="text" id="direct-filename"
                        placeholder="video_name (leave empty for auto-generated name)">
                    <div class="filename-error" id="direct-filename-error">A file with this name already exists</div>
                </div>

                <div class="input-group">
                    <label for="direct-format">Output Format</label>
                    <select id="direct-format">
                        <optgroup label="Video Formats">
                            <option value="mp4">MP4 (recommended)</option>
                            <option value="mkv">MKV</option>
                            <option value="webm">WebM</option>
                            <option value="avi">AVI</option>
                            <option value="mov">MOV</option>
                            <option value="ts">TS (Transport Stream)</option>
                            <option value="flv">FLV</option>
                            <option value="wmv">WMV</option>
                            <option value="m4v">M4V</option>
                        </optgroup>
                        <optgroup label="Audio Only">
                            <option value="mp3">MP3</option>
                            <option value="aac">AAC</option>
                            <option value="m4a">M4A</option>
                            <option value="flac">FLAC</option>
                            <option value="wav">WAV</option>
                            <option value="ogg">OGG</option>
                            <option value="opus">OPUS</option>
                            <option value="wma">WMA</option>
                        </optgroup>
                    </select>
                </div>

                <button class="btn" id="direct-download-btn" onclick="startDirectDownload()">
                    Download Now
                </button>

                <div class="status-box" id="direct-status"></div>
            </div>

            <!-- Browser Mode -->
            <div class="card">
                <h2><span class="icon">üîç</span> Find Link (Browser Mode)</h2>
                <p>Open a webpage in Chrome, detect and download the video stream</p>

                <div class="input-group">
                    <label for="browser-url">Webpage URL</label>
                    <input type="text" id="browser-url" placeholder="https://example.com/watch/video123">
                </div>

                <div class="input-group">
                    <label for="browser-filename">Filename (optional)</label>
                    <input type="text" id="browser-filename"
                        placeholder="video_name (leave empty for auto-generated name)">
                    <div class="filename-error" id="browser-filename-error">A file with this name already exists</div>
                </div>

                <div class="input-group">
                    <label for="browser-format">Output Format</label>
                    <select id="browser-format">
                        <optgroup label="Video Formats">
                            <option value="mp4">MP4 (recommended)</option>
                            <option value="mkv">MKV</option>
                            <option value="webm">WebM</option>
                            <option value="avi">AVI</option>
                            <option value="mov">MOV</option>
                            <option value="ts">TS (Transport Stream)</option>
                            <option value="flv">FLV</option>
                            <option value="wmv">WMV</option>
                            <option value="m4v">M4V</option>
                        </optgroup>
                        <optgroup label="Audio Only">
                            <option value="mp3">MP3</option>
                            <option value="aac">AAC</option>
                            <option value="m4a">M4A</option>
                            <option value="flac">FLAC</option>
                            <option value="wav">WAV</option>
                            <option value="ogg">OGG</option>
                            <option value="opus">OPUS</option>
                            <option value="wma">WMA</option>
                        </optgroup>
                    </select>
                </div>

                <div class="input-group">
                    <label>
                        <input type="checkbox" id="auto-download" style="width: auto; margin-right: 8px;">
                        Auto-download matching stream
                    </label>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="input-group">
                        <label for="preferred-resolution">Resolution</label>
                        <select id="preferred-resolution">
                            <option value="source" selected>Source/Highest</option>
                            <option value="1080p">1080p</option>
                            <option value="720p">720p</option>
                            <option value="480p">480p</option>
                            <option value="360p">360p</option>
                            <option value="160p">160p</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="preferred-framerate">Framerate</label>
                        <select id="preferred-framerate">
                            <option value="any" selected>Source/Highest</option>
                            <option value="60">60fps</option>
                            <option value="30">30fps</option>
                        </select>
                    </div>
                </div>

                <button class="btn" id="browser-start-btn" onclick="startBrowser()">
                    Open Browser & Detect
                </button>

                <button class="btn btn-secondary" id="clear-cookies-btn" onclick="clearCookies()">
                    üóëÔ∏è Clear Cookies
                </button>

                <div class="status-box" id="browser-status"></div>
            </div>

            <!-- VNC Container -->
            <div class="card vnc-container" id="vnc-container">
                <div class="vnc-header">
                    <h2><span class="icon">üñ•Ô∏è</span> Browser View</h2>
                    <button class="btn btn-secondary" style="width: auto; padding: 10px 20px;" onclick="closeBrowser()">
                        Close Browser
                    </button>
                </div>
                <p style="color: #666; margin-bottom: 10px; font-size: 0.9rem;">
                    üí° <strong>Tip:</strong> If you see "Connect" button, it will auto-connect. Any HTTP warnings can be
                    ignored - they're normal for local networks.
                </p>
                <iframe id="vnc-frame" class="vnc-frame" src=""></iframe>
            </div>

            <!-- Scheduled Downloads -->
            <!-- Scheduled Downloads -->
            <!-- Scheduled Downloads -->
            <div class="card">
                <h2><span class="icon">üìÖ</span> Scheduled Downloads</h2>
                <p>Schedule automatic stream checks. The browser will open the page and search for video streams.</p>

                <h3 style="margin-bottom: 15px; font-size: 1.1rem; color: #333;">Add New Schedule</h3>

                <div class="input-group">
                    <label for="sched-url">Webpage URL</label>
                    <input type="text" id="sched-url" placeholder="https://www.twitch.tv/channel">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="input-group">
                        <label for="sched-start">Start Time</label>
                        <input type="datetime-local" id="sched-start">
                    </div>
                    <div class="input-group">
                        <label for="sched-end">End Time</label>
                        <input type="datetime-local" id="sched-end">
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="input-group">
                        <label for="sched-resolution">Target Resolution</label>
                        <select id="sched-resolution" class="select-input">
                            <option value="source">Source (Best)</option>
                            <option value="2160p">4K (2160p)</option>
                            <option value="1440p">1440p</option>
                            <option value="1080p" selected>1080p</option>
                            <option value="720p">720p</option>
                            <option value="480p">480p</option>
                            <option value="360p">360p</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="sched-framerate">Target FPS</label>
                        <select id="sched-framerate" class="select-input">
                            <option value="any" selected>Any</option>
                            <option value="60">60 FPS</option>
                            <option value="30">30 FPS</option>
                        </select>
                    </div>
                </div>

                <div class="input-group">
                    <label>
                        <input type="checkbox" id="sched-repeat" style="width: auto; margin-right: 8px;">
                        Repeat Weekly (Same time next week)
                    </label>
                </div>

                <button class="btn" onclick="addSchedule()">
                    Add Schedule
                </button>

                <div class="status-box" id="sched-status" style="margin-top: 15px;"></div>
            </div>

            <!-- Active Schedules -->
            <div class="card">
                <h2><span class="icon">üìã</span> Active Schedules</h2>
                <div id="schedules-list" style="display: grid; gap: 10px; max-height: 400px; overflow-y: auto;">
                    <!-- Schedules will be loaded here -->
                </div>
            </div>

            <!-- Active Downloads -->
            <div class="card downloads-list">
                <h2><span class="icon">‚è¨</span> Active Downloads</h2>
                <div id="active-downloads-container">
                    <p style="color: #666; padding: 20px;">No active downloads</p>
                </div>
            </div>

            <!-- Completed Downloads -->
            <div class="card downloads-list">
                <h2><span class="icon">‚úÖ</span> Completed Downloads</h2>
                <div id="completed-downloads-container">
                    <p style="color: #666; padding: 20px;">Loading...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Success Popup -->
    <div class="popup-overlay" id="popup-overlay"></div>
    <div class="download-popup" id="download-popup">
        <h3>‚úì Download Started!</h3>
        <img class="thumbnail" id="popup-thumbnail" src="" alt="Video thumbnail">
        <div class="info">
            <p><strong>Stream Type:</strong> <span id="popup-stream-type"></span></p>
            <p><strong>Saving to:</strong> <span id="popup-filename"></span></p>
        </div>
        <div class="countdown" id="popup-countdown">
            Window closing in <strong>15</strong> seconds...
        </div>
        <div class="popup-buttons">
            <button class="btn" onclick="closePopup()">Close Now</button>
            <button class="btn btn-secondary" onclick="keepOpen()">Keep Open</button>
        </div>
    </div>

    <!-- Resolution Selection Popup -->
    <div class="download-popup" id="resolution-popup">
        <h3>üì∫ Detected Streams</h3>
        <p style="margin-bottom: 20px;">Select which stream to download:</p>
        <div id="resolution-options" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
            <!-- Resolution buttons will be added here dynamically -->
        </div>
        <button class="btn btn-secondary" onclick="closeResolutionPopup()">Cancel & Keep Browsing</button>
    </div>

    <!-- Download Started Popup -->
    <div class="download-popup" id="download-started-popup" style="max-width: 600px;">
        <h3>‚úÖ Download Started</h3>
        <div id="download-info" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
            <!-- Download info will be dynamically added here -->
        </div>
        <p id="countdown-text" style="text-align: center; color: #666; margin: 15px 0;">
            Browser will close automatically in <strong id="countdown">15</strong> seconds
        </p>
        <div id="browser-buttons" style="display: flex; gap: 10px; justify-content: center;">
            <button class="btn" onclick="closeBrowserNow()">üóô Close Browser Now</button>
            <button class="btn btn-secondary" onclick="keepBrowserOpen()">‚úì Keep Browser Open</button>
        </div>
        <div id="direct-buttons" style="display: none; justify-content: center;">
            <button class="btn" onclick="closeDownloadPopup()">‚úì OK</button>
        </div>
    </div>

    <!-- Debug Stream Log Popup -->
    <div class="download-popup" id="debug-popup" style="max-width: 800px;">
        <h3>üîç Debug: Detected Streams Log</h3>
        <p style="margin-bottom: 10px; color: #666;">Copy this log for debugging. Updates automatically as streams are
            detected.</p>
        <textarea id="debug-log" readonly
            style="width: 100%; height: 400px; font-family: monospace; font-size: 0.85rem; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; background: #f8f9fa; resize: vertical;"></textarea>
        <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button class="btn" onclick="copyDebugLog()">üìã Copy to Clipboard</button>
            <button class="btn btn-secondary" onclick="closeDebugPopup()">Close</button>
        </div>
    </div>

    <script>
        let currentBrowserId = null;
        let statusCheckInterval = null;
        let countdownInterval = null;
        let countdownValue = 15;
        let debugLogContent = '';
        let detectedStreamCount = 0;
        let downloadPopupShown = false;

        // Validate filename doesn't already exist
        async function validateFilename(inputId, errorId, format) {
            const input = document.getElementById(inputId);
            const errorDiv = document.getElementById(errorId);
            let filename = input.value.trim();

            if (!filename) {
                input.classList.remove('input-error');
                errorDiv.classList.remove('visible');
                return true; // Empty is valid (will be handled by required check)
            }

            // Auto-append extension if not present
            if (!filename.includes('.')) {
                filename = filename + '.' + format;
            }

            try {
                const response = await fetch(`/api/downloads/check-filename?filename=${encodeURIComponent(filename)}`);
                const data = await response.json();

                if (data.exists) {
                    input.classList.add('input-error');
                    errorDiv.classList.add('visible');
                    return false;
                } else {
                    input.classList.remove('input-error');
                    errorDiv.classList.remove('visible');
                    return true;
                }
            } catch (error) {
                console.error('Filename validation error:', error);
                return true; // Allow on error
            }
        }

        // Start direct download
        async function startDirectDownload() {
            const url = document.getElementById('direct-url').value.trim();
            let filename = document.getElementById('direct-filename').value.trim();
            const format = document.getElementById('direct-format').value;
            const statusBox = document.getElementById('direct-status');
            const btn = document.getElementById('direct-download-btn');

            if (!url) {
                showStatus(statusBox, 'Please enter a stream URL', 'error');
                return;
            }

            // Auto-generate filename if empty
            if (!filename) {
                const timestamp = Date.now();
                filename = `video_${timestamp}.${format}`;
            } else {
                // Check if filename exists (only if user provided one)
                const isValid = await validateFilename('direct-filename', 'direct-filename-error', format);
                if (!isValid) {
                    showStatus(statusBox, 'Please choose a different filename - this one already exists', 'error');
                    return;
                }

                // Auto-append extension if not present
                if (!filename.includes('.')) {
                    filename = filename + '.' + format;
                }
            }

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Starting download...';

            try {
                const response = await fetch('/api/downloads/direct', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, filename })
                });

                const data = await response.json();

                if (data.success) {
                    showStatus(statusBox, `‚úì Download started! Extracting metadata with ffmpeg...`, 'success');

                    // Poll for metadata and thumbnail (ffmpeg extracts these from the stream)
                    pollDirectDownloadStatus(data.browser_id);

                    setTimeout(() => loadDownloads(), 2000);
                } else {
                    showStatus(statusBox, `Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(statusBox, `Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Download Now';
            }
        }

        // Start browser mode
        async function startBrowser() {
            const url = document.getElementById('browser-url').value.trim();
            let filename = document.getElementById('browser-filename').value.trim();
            const format = document.getElementById('browser-format').value;
            const resolution = document.getElementById('preferred-resolution').value;
            const framerate = document.getElementById('preferred-framerate').value;
            const autoDownload = document.getElementById('auto-download').checked;
            const statusBox = document.getElementById('browser-status');
            const btn = document.getElementById('browser-start-btn');

            if (!url) {
                showStatus(statusBox, 'Please enter a webpage URL', 'error');
                return;
            }

            // Check if filename exists (only if filename is provided)
            if (filename) {
                const isValid = await validateFilename('browser-filename', 'browser-filename-error', format);
                if (!isValid) {
                    showStatus(statusBox, 'Please choose a different filename - this one already exists', 'error');
                    return;
                }
            }

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Starting browser...';

            try {
                const payload = {
                    url,
                    resolution: resolution,
                    framerate: framerate,
                    auto_download: autoDownload,
                    format: format
                };

                // Only add filename if provided (with auto extension)
                if (filename) {
                    if (!filename.includes('.')) {
                        filename = filename + '.' + format;
                    }
                    payload.filename = filename;
                }

                const response = await fetch('/api/browser/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.success) {
                    currentBrowserId = data.browser_id;
                    downloadPopupShown = false; // Reset for new session
                    const resolutionText = framerate === 'any' ? `${resolution} (any framerate)` : `${resolution} ${framerate}fps`;
                    const modeText = autoDownload ? 'auto-download enabled' : 'manual selection';
                    showStatus(statusBox, `‚úì Browser started! Looking for ${resolutionText} (${modeText})...`, 'success');

                    // Only show VNC viewer initially if NOT in auto-download mode
                    // In auto-download mode, VNC will only show if manual selection is needed
                    if (!autoDownload) {
                        const vncContainer = document.getElementById('vnc-container');
                        const vncFrame = document.getElementById('vnc-frame');

                        // Auto-connect to VNC and hide toolbar
                        const vncUrl = 'http://' + window.location.hostname + ':6080/vnc.html?autoconnect=true&resize=scale';
                        vncFrame.src = vncUrl;
                        vncContainer.classList.add('active');

                        // Scroll to VNC viewer
                        setTimeout(() => {
                            vncContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 500);
                    }

                    // Update button to show browser is running
                    btn.disabled = false;
                    btn.innerHTML = '‚úì Browser Running';

                    // Start status polling
                    startStatusPolling();
                } else {
                    showStatus(statusBox, `Error: ${data.error}`, 'error');
                    btn.disabled = false;
                    btn.innerHTML = 'Open Browser & Detect';
                }
            } catch (error) {
                showStatus(statusBox, `Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = 'Open Browser & Detect';
            }
        }

        // Poll direct download status (just for metadata and thumbnail, no browser)
        async function pollDirectDownloadStatus(browserId) {
            let attempts = 0;
            const maxAttempts = 10; // 10 seconds max

            const checkStatus = async () => {
                try {
                    const response = await fetch(`/api/browser/status/${browserId}`);
                    const data = await response.json();

                    console.log('Direct download status check:', data);

                    // Check if metadata and thumbnail are ready
                    if (data.download_started && data.selected_stream_metadata) {
                        console.log('‚úì Direct download metadata ready');

                        // Show popup with metadata and thumbnail (isDirect = true)
                        showDownloadStartedPopup(data.selected_stream_metadata, data.thumbnail, true);

                        // Stop polling
                        return true;
                    }

                    attempts++;
                    if (attempts < maxAttempts) {
                        // Poll again in 1 second
                        setTimeout(checkStatus, 1000);
                    } else {
                        console.log('Direct download metadata timeout - showing without thumbnail');
                        // Show popup without thumbnail if timeout (isDirect = true)
                        showDownloadStartedPopup({ name: 'Direct Download', resolution: 'Processing...', framerate: '' }, null, true);
                    }
                } catch (error) {
                    console.error('Error checking direct download status:', error);
                    attempts++;
                    if (attempts < maxAttempts) {
                        setTimeout(checkStatus, 1000);
                    }
                }
            };

            // Start checking
            checkStatus();
        }

        // Poll browser status
        function startStatusPolling() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }

            statusCheckInterval = setInterval(async () => {
                if (!currentBrowserId) return;

                try {
                    const response = await fetch(`/api/browser/status/${currentBrowserId}`);
                    const data = await response.json();

                    // DEBUG: Log status data
                    console.log('=== BROWSER STATUS UPDATE ===');
                    console.log('Browser ID:', currentBrowserId);
                    console.log('Is Running:', data.is_running);
                    console.log('Download Started:', data.download_started);
                    console.log('Detected Streams Count:', data.detected_streams);
                    console.log('Awaiting Resolution Selection:', data.awaiting_resolution_selection);

                    // Show stream selection modal if streams are available and manual mode
                    if (data.awaiting_resolution_selection && data.available_resolutions && data.available_resolutions.length > 0) {
                        console.log('=== AVAILABLE STREAMS ===');
                        console.log('Count:', data.available_resolutions.length);

                        data.available_resolutions.forEach((res, index) => {
                            console.log(`--- Stream ${index + 1} ---`);
                            console.log('Name:', res.name);
                            console.log('Resolution:', res.resolution);
                            console.log('Framerate:', res.framerate);
                        });

                        // Show VNC browser if not already shown (needed for manual selection)
                        const vncContainer = document.getElementById('vnc-container');
                        if (!vncContainer.classList.contains('active')) {
                            const vncFrame = document.getElementById('vnc-frame');
                            const vncUrl = 'http://' + window.location.hostname + ':6080/vnc.html?autoconnect=true&resize=scale';
                            vncFrame.src = vncUrl;
                            vncContainer.classList.add('active');
                            setTimeout(() => {
                                vncContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }, 500);
                        }

                        // Show modal with all available streams
                        showStreamModal(data.available_resolutions);

                        const statusBox = document.getElementById('browser-status');
                        showStatus(statusBox, `‚úì Found ${data.available_resolutions.length} streams - Select one to download`, 'success');
                    }

                    // Handle download started (both auto and manual)
                    if (data.download_started && !downloadPopupShown) {
                        console.log('‚úì Download started');
                        downloadPopupShown = true;
                        const statusBox = document.getElementById('browser-status');
                        showStatus(statusBox, '‚úì Download started!', 'success');

                        // Show download confirmation popup
                        showDownloadStartedPopup(data.selected_stream_metadata, data.thumbnail);

                        setTimeout(() => loadDownloads(), 2000);
                    }

                    if (!data.is_running) {
                        console.log('!!! BROWSER STOPPED !!!');
                        clearInterval(statusCheckInterval);

                        // Reset button and hide VNC
                        const btn = document.getElementById('browser-start-btn');
                        btn.disabled = false;
                        btn.innerHTML = 'Open Browser & Detect';

                        const vncContainer = document.getElementById('vnc-container');
                        vncContainer.classList.remove('active');

                        currentBrowserId = null;
                        loadDownloads();
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                }
            }, 2000);
        }

        // Show download popup
        function showDownloadPopup(data) {
            const popup = document.getElementById('download-popup');
            const overlay = document.getElementById('popup-overlay');
            const thumbnail = document.getElementById('popup-thumbnail');
            const streamType = document.getElementById('popup-stream-type');
            const filename = document.getElementById('popup-filename');

            // Set data
            if (data.thumbnail) {
                thumbnail.src = 'data:image/png;base64,' + data.thumbnail;
            }

            if (data.latest_stream) {
                streamType.textContent = data.latest_stream.type;
            }

            if (data.download) {
                filename.textContent = data.download.output_path;
            }

            // Show popup
            popup.classList.add('active');
            overlay.classList.add('active');

            // DEBUG MODE: Countdown timer disabled
            // startCountdown();
        }

        // Start countdown (DISABLED FOR DEBUGGING)
        function startCountdown() {
            // countdownValue = 15;
            // updateCountdown();
            // countdownInterval = setInterval(() => {
            //     countdownValue--;
            //     updateCountdown();
            //     if (countdownValue <= 0) {
            //         clearInterval(countdownInterval);
            //         closePopup();
            //         closeBrowser();
            //     }
            // }, 1000);
        }

        // Update countdown display
        function updateCountdown() {
            const countdown = document.getElementById('popup-countdown');
            countdown.innerHTML = `Download in progress - browser will stay open`;
        }

        // Close popup
        function closePopup() {
            const popup = document.getElementById('download-popup');
            const overlay = document.getElementById('popup-overlay');

            popup.classList.remove('active');
            overlay.classList.remove('active');

            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
        }

        // Keep browser open
        function keepOpen() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            closePopup();

            const statusBox = document.getElementById('browser-status');
            showStatus(statusBox, 'Browser kept open. Close manually when done.', 'success');
        }

        // Show resolution selection popup
        function showResolutionPopup(resolutions) {
            const popup = document.getElementById('resolution-popup');
            const overlay = document.getElementById('popup-overlay');
            const optionsContainer = document.getElementById('resolution-options');

            // Clear existing options
            optionsContainer.innerHTML = '';

            // Add resolution buttons with detailed info
            resolutions.forEach(res => {
                const card = document.createElement('div');
                card.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px; cursor: pointer; border: 2px solid #e0e0e0; transition: all 0.2s;';
                card.onmouseover = () => card.style.borderColor = '#667eea';
                card.onmouseout = () => card.style.borderColor = '#e0e0e0';
                card.onclick = () => selectResolution(res);

                const title = document.createElement('h4');
                title.style.cssText = 'margin: 0 0 8px 0; color: #667eea; font-size: 1.1rem;';
                title.textContent = res.name || 'Unknown';

                const details = document.createElement('div');
                details.style.cssText = 'font-size: 0.9rem; color: #666;';

                const resolution = res.resolution || 'Unknown';
                const framerate = res.framerate ? Math.round(parseFloat(res.framerate)) + ' fps' : 'Unknown';

                details.innerHTML = `
                    <p style="margin: 4px 0;"><strong>Resolution:</strong> ${resolution}</p>
                    <p style="margin: 4px 0;"><strong>Framerate:</strong> ${framerate}</p>
                    <p style="margin: 4px 0; font-size: 0.75rem; word-break: break-all;"><strong>URL:</strong> ${res.url.substring(0, 80)}...</p>
                `;

                card.appendChild(title);
                card.appendChild(details);
                optionsContainer.appendChild(card);
            });

            // Show popup
            popup.classList.add('active');
            overlay.classList.add('active');
        }

        // Select a resolution
        async function selectResolution(stream) {
            closeResolutionPopup();

            const statusBox = document.getElementById('browser-status');
            showStatus(statusBox, `‚úì Starting download for ${stream.name}...`, 'success');

            try {
                const response = await fetch('/api/browser/select-resolution', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        browser_id: currentBrowserId,
                        stream: stream
                    })
                });

                const data = await response.json();
                if (!data.success) {
                    showStatus(statusBox, `Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(statusBox, `Error: ${error.message}`, 'error');
            }
        }

        // Close resolution popup
        function closeResolutionPopup() {
            const popup = document.getElementById('resolution-popup');
            const overlay = document.getElementById('popup-overlay');

            popup.classList.remove('active');
            overlay.classList.remove('active');
        }

        // Show debug popup
        function showDebugPopup() {
            const popup = document.getElementById('debug-popup');
            const overlay = document.getElementById('popup-overlay');

            popup.classList.add('active');
            overlay.classList.add('active');
        }

        // Update debug log with stream information
        function updateDebugLog(resolutions) {
            const timestamp = new Date().toISOString();
            let newContent = `\n=== STREAM DETECTION UPDATE @ ${timestamp} ===\n`;
            newContent += `Total Streams Detected: ${resolutions.length}\n\n`;

            resolutions.forEach((res, index) => {
                newContent += `--- Stream ${index + 1} ---\n`;
                newContent += `Name: ${res.name || 'Unknown'}\n`;
                newContent += `Resolution: ${res.resolution || 'Unknown'}\n`;
                newContent += `Framerate: ${res.framerate || 'Unknown'}\n`;
                newContent += `Codecs: ${res.codecs || 'Unknown'}\n`;
                newContent += `URL: ${res.url}\n`;
                newContent += `\n`;
            });

            // Append to existing content
            debugLogContent += newContent;

            // Update textarea
            const textarea = document.getElementById('debug-log');
            textarea.value = debugLogContent;

            // Auto-scroll to bottom
            textarea.scrollTop = textarea.scrollHeight;
        }

        // Copy debug log to clipboard
        function copyDebugLog() {
            const textarea = document.getElementById('debug-log');
            textarea.select();
            document.execCommand('copy');

            // Show feedback
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚úì Copied!';
            setTimeout(() => {
                btn.innerHTML = originalText;
            }, 2000);
        }

        // Close debug popup
        function closeDebugPopup() {
            const popup = document.getElementById('debug-popup');
            const overlay = document.getElementById('popup-overlay');

            popup.classList.remove('active');
            overlay.classList.remove('active');
        }

        // Show download started popup
        function showDownloadStartedPopup(streamMetadata, thumbnail, isDirect = false) {
            const popup = document.getElementById('download-started-popup');
            const overlay = document.getElementById('popup-overlay');
            const infoContainer = document.getElementById('download-info');
            const countdownText = document.getElementById('countdown-text');
            const browserButtons = document.getElementById('browser-buttons');
            const directButtons = document.getElementById('direct-buttons');

            // Force close stream selection modal if open
            closeStreamModal();

            // Populate download info
            const resolution = streamMetadata?.resolution || 'Unknown';
            const framerate = streamMetadata?.framerate ? Math.round(parseFloat(streamMetadata.framerate)) + ' fps' : 'Unknown';
            const name = streamMetadata?.name || 'Video';

            let infoHTML = `
                <h4 style="margin: 0 0 10px 0; color: #667eea;">${name}</h4>
                <p style="margin: 4px 0;"><strong>Resolution:</strong> ${resolution}</p>
                <p style="margin: 4px 0;"><strong>Framerate:</strong> ${framerate}</p>
            `;

            // Add thumbnail if available
            if (thumbnail) {
                infoHTML = `<img src="data:image/png;base64,${thumbnail}" style="width: 100%; border-radius: 8px; margin-bottom: 10px;" />` + infoHTML;
            }

            infoContainer.innerHTML = infoHTML;

            // Show/hide appropriate elements based on download type
            if (isDirect) {
                // Direct download: just show OK button, no countdown
                countdownText.style.display = 'none';
                browserButtons.style.display = 'none';
                directButtons.style.display = 'flex';
            } else {
                // Browser download: show countdown and browser control buttons
                countdownText.style.display = 'block';
                browserButtons.style.display = 'flex';
                directButtons.style.display = 'none';
                // Start 15 second countdown
                startDownloadCountdown();
            }

            // Show popup
            popup.classList.add('active');
            overlay.classList.add('active');
        }

        // Start countdown timer
        function startDownloadCountdown() {
            countdownValue = 15;
            const countdownElement = document.getElementById('countdown');
            countdownElement.textContent = countdownValue;

            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            countdownInterval = setInterval(() => {
                countdownValue--;
                countdownElement.textContent = countdownValue;

                if (countdownValue <= 0) {
                    clearInterval(countdownInterval);
                    closeBrowserNow();
                }
            }, 1000);
        }

        // Close browser now (from download popup)
        async function closeBrowserNow() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            const popup = document.getElementById('download-started-popup');
            const overlay = document.getElementById('popup-overlay');
            popup.classList.remove('active');
            overlay.classList.remove('active');

            await closeBrowser();
        }

        // Keep browser open (from download popup)
        function keepBrowserOpen() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            const popup = document.getElementById('download-started-popup');
            const overlay = document.getElementById('popup-overlay');
            popup.classList.remove('active');
            overlay.classList.remove('active');

            const statusBox = document.getElementById('browser-status');
            showStatus(statusBox, 'Browser kept open. Close manually when done.', 'success');
        }

        // Close download popup (for direct downloads - no browser to close)
        function closeDownloadPopup() {
            const popup = document.getElementById('download-started-popup');
            const overlay = document.getElementById('popup-overlay');
            popup.classList.remove('active');
            overlay.classList.remove('active');
        }

        // Close browser
        async function closeBrowser() {
            if (!currentBrowserId) return;

            try {
                await fetch(`/api/browser/close/${currentBrowserId}`, {
                    method: 'POST'
                });

                const vncContainer = document.getElementById('vnc-container');
                vncContainer.classList.remove('active');

                currentBrowserId = null;

                if (statusCheckInterval) {
                    clearInterval(statusCheckInterval);
                }

                // Reset the button
                const btn = document.getElementById('browser-start-btn');
                btn.disabled = false;
                btn.innerHTML = 'Open Browser & Detect';

                loadDownloads();
            } catch (error) {
                console.error('Close browser error:', error);
            }
        }

        // Clear cookies and Chrome profile data
        async function clearCookies() {
            const statusBox = document.getElementById('browser-status');
            const btn = document.getElementById('clear-cookies-btn');

            // Confirmation dialog
            if (!confirm('This will close all browser sessions and clear all cookies and login data. Continue?')) {
                return;
            }

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Clearing...';
            showStatus(statusBox, 'Closing browsers and clearing cookies...', 'error');

            try {
                const response = await fetch('/api/browser/clear-cookies', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    showStatus(statusBox, '‚úì ' + data.message, 'success');

                    // Close VNC viewer if open
                    const vncContainer = document.getElementById('vnc-container');
                    vncContainer.classList.remove('active');
                    currentBrowserId = null;

                    if (statusCheckInterval) {
                        clearInterval(statusCheckInterval);
                    }
                } else {
                    showStatus(statusBox, `Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(statusBox, `Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üóëÔ∏è Clear Cookies';
            }
        }

        // Load downloads list
        async function loadDownloads() {
            try {
                const response = await fetch('/api/downloads/active');
                const data = await response.json();

                const container = document.getElementById('active-downloads-container');
                container.innerHTML = '';

                if (data.active_downloads && data.active_downloads.length > 0) {
                    data.active_downloads.forEach(download => {
                        const item = document.createElement('div');
                        item.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 2px solid #e0e0e0;';

                        const sizeMB = (download.size / (1024 * 1024)).toFixed(2);
                        const minutes = Math.floor(download.duration / 60);
                        const seconds = download.duration % 60;
                        const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        const statusIcon = download.is_running ? '‚è¨' : '‚úì';
                        const statusText = download.is_running ? 'Downloading...' : 'Completed';

                        item.innerHTML = `
                            <div style="display: flex; gap: 15px; align-items: center;">
                                ${download.thumbnail ? `
                                    <div style="flex-shrink: 0;">
                                        <img src="data:image/png;base64,${download.thumbnail}"
                                             style="width: 160px; height: 90px; object-fit: cover; border-radius: 8px; border: 2px solid #667eea;"
                                             alt="Video preview">
                                    </div>
                                ` : ''}
                                <div style="flex: 1;">
                                    <h4 style="margin: 0 0 8px 0; color: #667eea;">${statusIcon} ${download.filename}</h4>
                                    <p style="margin: 4px 0; color: #666; font-size: 0.9rem;"><strong>Resolution:</strong> ${download.resolution}</p>
                                    <p style="margin: 4px 0; color: #666; font-size: 0.9rem;"><strong>Size:</strong> ${sizeMB} MB &nbsp;&nbsp; <strong>Duration:</strong> ${timeStr}</p>
                                    <p style="margin: 4px 0; color: #666; font-size: 0.9rem;"><strong>Status:</strong> ${statusText}</p>
                                </div>
                                <div style="flex-shrink: 0;">
                                    ${download.is_running ? `<button class="btn btn-secondary" onclick="stopDownload('${download.browser_id}', this)" style="background: #dc3545;">‚èπ Stop</button>` : ''}
                                </div>
                            </div>
                        `;

                        container.appendChild(item);
                    });
                } else {
                    container.innerHTML = '<p style="color: #666; padding: 20px;">No active downloads</p>';
                }
            } catch (error) {
                console.error('Load downloads error:', error);
            }
        }

        async function stopDownload(browserId, buttonElement) {
            try {
                // Show deleting state
                if (buttonElement) {
                    buttonElement.disabled = true;
                    buttonElement.innerHTML = '<span class="spinner"></span> Stopping...';
                }

                const response = await fetch(`/api/downloads/stop/${browserId}`, {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    loadDownloads();
                } else {
                    // Restore button on failure
                    if (buttonElement) {
                        buttonElement.disabled = false;
                        buttonElement.innerHTML = '‚èπ Stop';
                    }
                }
            } catch (error) {
                console.error('Stop download error:', error);
                // Restore button on error
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = '‚èπ Stop';
                }
            }
        }

        // Load completed downloads
        async function loadCompletedDownloads() {
            try {
                const response = await fetch('/api/downloads/list');
                const data = await response.json();

                const container = document.getElementById('completed-downloads-container');
                container.innerHTML = '';

                if (data.downloads && data.downloads.length > 0) {
                    data.downloads.forEach(download => {
                        const item = document.createElement('div');
                        item.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 2px solid #e0e0e0;';
                        item.id = `completed-${download.filename}`;

                        const sizeMB = (download.size / (1024 * 1024)).toFixed(2);
                        const minutes = Math.floor(download.duration / 60);
                        const seconds = download.duration % 60;
                        const timeStr = download.duration > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : 'Unknown';
                        const resolutionStr = download.framerate ? `${download.resolution}@${download.framerate}` : download.resolution;

                        item.innerHTML = `
                            <div style="display: flex; gap: 15px; align-items: center;">
                                ${download.thumbnail ? `
                                    <div style="flex-shrink: 0;">
                                        <img src="data:image/jpeg;base64,${download.thumbnail}"
                                             style="width: 160px; height: 90px; object-fit: cover; border-radius: 8px; border: 2px solid #28a745;"
                                             alt="Video preview">
                                    </div>
                                ` : `
                                    <div style="flex-shrink: 0; width: 160px; height: 90px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center; color: white; font-size: 32px;">
                                        üé¨
                                    </div>
                                `}
                                <div style="flex: 1;">
                                    <h4 style="margin: 0 0 8px 0; color: #28a745;">‚úì ${download.filename}</h4>
                                    <p style="margin: 4px 0; color: #666; font-size: 0.9rem;"><strong>Resolution:</strong> ${resolutionStr}</p>
                                    <p style="margin: 4px 0; color: #666; font-size: 0.9rem;"><strong>Size:</strong> ${sizeMB} MB &nbsp;&nbsp; <strong>Duration:</strong> ${timeStr}</p>
                                </div>
                                <div style="flex-shrink: 0;">
                                    <button class="btn btn-secondary" onclick="deleteDownload('${download.filename}', this)" style="background: #dc3545;">üóë Delete</button>
                                </div>
                            </div>
                        `;

                        container.appendChild(item);
                    });
                } else {
                    container.innerHTML = '<p style="color: #666; padding: 20px;">No completed downloads</p>';
                }
            } catch (error) {
                console.error('Load completed downloads error:', error);
            }
        }

        async function deleteDownload(filename, buttonElement) {
            try {
                // Show deleting state
                if (buttonElement) {
                    buttonElement.disabled = true;
                    buttonElement.innerHTML = '<span class="spinner"></span> Deleting...';
                }

                const response = await fetch(`/api/downloads/delete/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.success) {
                    loadCompletedDownloads();
                } else {
                    // Restore button on failure
                    if (buttonElement) {
                        buttonElement.disabled = false;
                        buttonElement.innerHTML = 'üóë Delete';
                    }
                    alert('Failed to delete: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Delete download error:', error);
                // Restore button on error
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = 'üóë Delete';
                }
            }
        }

        // Show status message
        // Store timeout IDs for each status element
        const statusTimeouts = new Map();

        function showStatus(element, message, type) {
            element.textContent = message;
            element.className = 'status-box active ' + type;
            element.style.display = 'block';  // Explicitly show

            // Clear any existing timeout for this element
            if (statusTimeouts.has(element)) {
                clearTimeout(statusTimeouts.get(element));
            }

            // Set 10 second auto-hide timer
            const timeoutId = setTimeout(() => {
                element.classList.remove('active');
                element.style.display = 'none';  // Explicitly hide
                statusTimeouts.delete(element);
            }, 10000);

            statusTimeouts.set(element, timeoutId);
        }

        // Stream selection modal handling
        let displayedStreams = new Set();  // Track which streams we've already shown

        function closeStreamModal() {
            document.getElementById('stream-modal').classList.remove('active');
        }

        function showStreamModal(streams) {
            const modal = document.getElementById('stream-modal');
            const container = document.getElementById('streams-container');

            // Filter out streams we've already displayed
            const newStreams = streams.filter(stream => {
                const streamId = `${stream.name}-${stream.resolution}-${stream.framerate}`;
                if (displayedStreams.has(streamId)) {
                    return false;
                }
                displayedStreams.add(streamId);
                return true;
            });

            // If no new streams, don't show modal
            if (newStreams.length === 0) {
                return;
            }

            // Add new streams to the container (append, don't replace)
            newStreams.forEach(stream => {
                const card = document.createElement('div');
                card.className = 'stream-card';

                // Format framerate
                const framerate = stream.framerate ?
                    `${stream.framerate} fps` :
                    'Unknown';

                card.innerHTML = `
                    <div class="stream-thumbnail">
                        ${stream.thumbnail ?
                        `<img src="${stream.thumbnail}" alt="${stream.name}">` :
                        'üé¨'
                    }
                    </div>
                    <div class="stream-details">
                        <h3>${stream.name}</h3>
                        <div class="stream-detail-row">
                            <span class="stream-detail-label">Resolution:</span>
                            <span>${stream.resolution || 'Unknown'}</span>
                        </div>
                        <div class="stream-detail-row">
                            <span class="stream-detail-label">Framerate:</span>
                            <span>${framerate}</span>
                        </div>
                        <div class="stream-detail-row">
                            <span class="stream-detail-label">Codec:</span>
                            <span>${stream.codecs || 'Unknown'}</span>
                        </div>
                    </div>
                    <button class="stream-download-btn" onclick='downloadStream(${JSON.stringify(stream)})'>
                        üì• Download This Stream
                    </button>
                `;

                container.appendChild(card);
            });

            modal.classList.add('active');
        }

        async function downloadStream(stream) {
            console.log('Downloading stream:', stream);

            try {
                const response = await fetch('/api/browser/select-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        browser_id: currentBrowserId,
                        stream_url: stream.url
                    })
                });

                const data = await response.json();

                if (data.success) {
                    closeStreamModal();
                    const statusBox = document.getElementById('browser-status');
                    showStatus(statusBox, `‚úì Download started! ${stream.name} (${stream.resolution})`, 'success');
                    setTimeout(() => loadDownloads(), 2000);
                } else {
                    alert(`Error: ${data.error}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        // Schedules
        async function loadSchedules() {
            try {
                const response = await fetch('/api/schedules/');
                const schedules = await response.json();

                const container = document.getElementById('schedules-list');
                container.innerHTML = '';

                if (schedules.length === 0) {
                    container.innerHTML = '<p style="color: #666; font-size: 0.9rem;">No active schedules</p>';
                    return;
                }

                schedules.forEach(sched => {
                    const item = document.createElement('div');
                    item.className = 'download-item';

                    const start = new Date(sched.start_time).toLocaleString();
                    const end = new Date(sched.end_time).toLocaleString();
                    const nextCheck = sched.next_check ? new Date(sched.next_check).toLocaleTimeString() : 'Pending window';

                    let statusColor = '#666';
                    if (sched.status === 'active') statusColor = '#28a745';
                    if (sched.status === 'download_started') statusColor = '#17a2b8';

                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px;">
                            <div style="overflow: hidden;">
                                <h4 title="${sched.url}">${sched.name || sched.url}</h4>
                                <p><strong>Window:</strong> <br>${start} <br>to ${end}</p>
                                <p><strong>Repeat:</strong> ${sched.repeat ? 'Yes' : 'No'}</p>
                                <p style="color: ${statusColor}"><strong>Status:</strong> ${sched.status} ${sched.next_check ? `(Next check: ${nextCheck})` : ''}</p>
                            </div>
                            <button class="btn btn-secondary" style="width: auto; padding: 5px 10px; font-size: 0.8rem; background: #dc3545;" onclick="deleteSchedule('${sched.id}', this)">DELETE</button>
                        </div>
                    `;
                    container.appendChild(item);
                });

            } catch (error) {
                console.error('Error loading schedules:', error);
            }
        }

        async function addSchedule() {
            const url = document.getElementById('sched-url').value.trim();
            const start = document.getElementById('sched-start').value;
            const end = document.getElementById('sched-end').value;
            const repeat = document.getElementById('sched-repeat').checked;
            const resolution = document.getElementById('sched-resolution').value;
            const framerate = document.getElementById('sched-framerate').value;
            const statusBox = document.getElementById('sched-status');

            if (!url || !start || !end) {
                showStatus(statusBox, 'Please fill all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/schedules/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: url,
                        start_time: start,
                        end_time: end,
                        repeat: repeat,
                        resolution: resolution,
                        framerate: framerate,
                        name: url.substring(0, 30) + '...'
                    })
                });

                const data = await response.json();
                if (data.success) {
                    showStatus(statusBox, 'Schedule added!', 'success');
                    document.getElementById('sched-url').value = '';
                    loadSchedules();
                } else {
                    showStatus(statusBox, 'Error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus(statusBox, 'Error: ' + error.message, 'error');
            }
        }

        async function deleteSchedule(id, btn) {
            if (!confirm('Delete this schedule?')) return;

            try {
                btn.disabled = true;
                const response = await fetch(`/api/schedules/${id}`, { method: 'DELETE' });
                const data = await response.json();

                if (data.success) {
                    loadSchedules();
                } else {
                    alert('Error: ' + data.error);
                    btn.disabled = false;
                }
            } catch (error) {
                console.error(error);
                btn.disabled = false;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadDownloads();
            loadSchedules();
            loadCompletedDownloads();
            setInterval(loadSchedules, 10000); // Refresh schedules every 10s
            setInterval(loadDownloads, 1000); // Refresh active downloads every 1 second
            setInterval(loadCompletedDownloads, 10000); // Refresh completed downloads every 10 seconds

            // Close modal when clicking outside of it
            window.onclick = function (event) {
                const modal = document.getElementById('stream-modal');
                if (event.target === modal) {
                    closeStreamModal();
                }
            };

            // Add blur event listeners for filename validation
            document.getElementById('direct-filename').addEventListener('blur', () => {
                const format = document.getElementById('direct-format').value;
                validateFilename('direct-filename', 'direct-filename-error', format);
            });

            document.getElementById('browser-filename').addEventListener('blur', () => {
                const format = document.getElementById('browser-format').value;
                validateFilename('browser-filename', 'browser-filename-error', format);
            });
        });
    </script>

    <!-- Stream Selection Modal -->
    <div id="stream-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üì∫ Select Stream to Download</h2>
                <span class="close-modal" onclick="closeStreamModal()">&times;</span>
            </div>
            <div id="streams-container" class="streams-grid">
                <!-- Streams will be dynamically added here -->
            </div>
        </div>
    </div>

</body>

</html>